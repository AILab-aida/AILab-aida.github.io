<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.4.0">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="AILab-aida" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: true,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="在之前学习机器学习技术中，很少关注特征工程 (Feature Engineering)，而且机器学习的书中基本上是已经处理好的数据或者作者自己构造的虚拟的数据。所以在机器学习的实践中，可能会选择使用这些算法，但是常常不知道怎么提取特征来建模。因此，结合网上的资料和项目中的经验试着来总结一下。特征是对于分析和解决问题有用、有意义的属性。例如：在表格数据中，表格中的一行是一个观测，但是表格的一列可能才">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="特征工程">
<meta property="og:url" content="https://ailab-aida.github.io/2019/10/28/特征工程/index.html">
<meta property="og:site_name" content="AILab-aida">
<meta property="og:description" content="在之前学习机器学习技术中，很少关注特征工程 (Feature Engineering)，而且机器学习的书中基本上是已经处理好的数据或者作者自己构造的虚拟的数据。所以在机器学习的实践中，可能会选择使用这些算法，但是常常不知道怎么提取特征来建模。因此，结合网上的资料和项目中的经验试着来总结一下。特征是对于分析和解决问题有用、有意义的属性。例如：在表格数据中，表格中的一行是一个观测，但是表格的一列可能才">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://tech.dianwoda.com/content/images/2018/04/--------.jpg">
<meta property="og:updated_time" content="2019-10-28T12:02:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="特征工程">
<meta name="twitter:description" content="在之前学习机器学习技术中，很少关注特征工程 (Feature Engineering)，而且机器学习的书中基本上是已经处理好的数据或者作者自己构造的虚拟的数据。所以在机器学习的实践中，可能会选择使用这些算法，但是常常不知道怎么提取特征来建模。因此，结合网上的资料和项目中的经验试着来总结一下。特征是对于分析和解决问题有用、有意义的属性。例如：在表格数据中，表格中的一行是一个观测，但是表格的一列可能才">
<meta name="twitter:image" content="http://tech.dianwoda.com/content/images/2018/04/--------.jpg">
  <link rel="canonical" href="https://ailab-aida.github.io/2019/10/28/特征工程/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>特征工程 | AILab-aida</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AILab-aida</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一个专注技术的组织</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-sitemap">
      
    

    <a href="/atom.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/qq1074123922" class="github-corner" title="AILab-aida GitHub" aria-label="AILab-aida GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://ailab-aida.github.io/2019/10/28/特征工程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AILab-aida">
      <meta itemprop="description" content="涉猎的主要编程语言为 深度学习、机器学习、大数据、服务端、移动端、前端、爬虫(go、scala、Java、flutter、Python、react、Vue)等。">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AILab-aida">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">特征工程

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-28 19:36:12 / 修改时间：20:02:05" itemprop="dateCreated datePublished" datetime="2019-10-28T19:36:12+08:00">2019-10-28</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在之前学习机器学习技术中，很少关注特征工程 (Feature Engineering)，而且机器学习的书中基本上是已经处理好的数据或者作者自己构造的虚拟的数据。所以在机器学习的实践中，可能会选择使用这些算法，但是常常不知道怎么提取特征来建模。因此，结合网上的资料和项目中的经验试着来总结一下。</p><p>特征是对于分析和解决问题有用、有意义的属性。例如：<br>在表格数据中，表格中的一行是一个观测，但是表格的一列可能才是特征；<br>在机器视觉中，一幅图像是一个观测，但是图中的一条线可能才是特征；<br>在自然语言处理中，一个文本是一个观测，但是其中的段落或者词频可能才是一种特征；<br>在语音识别中，一段语音是一个观测，但是一个词或者音素才是一种特征。</p><a id="more"></a>

<p>利用数据领域的相关知识来创建能够使机器学习算法达到最佳性能的特征的过程。 简而言之，特征工程就是一个把原始数据转变成特征的过程，这些特征可以很好的描述这些数据，并且利用它们建立的模型在未知数据上的表现性能可以达到最优（或者接近最佳性能）。<br>从数学的角度来看，特征工程就是人工地去设计输入变量 X。</p>
<h2 id="特征工程的意义"><a href="#特征工程的意义" class="headerlink" title="特征工程的意义"></a>特征工程的意义</h2><p>根据经验，模型的效果 80% 以上取决于特征。另一方面，好的特征能使得模型的性能得到提升，有时甚至在简单的模型上也能取得不错的效果，这样就不必费力去选择最适合的模型和最优的参数了。</p>
<h2 id="特征要考虑的因素"><a href="#特征要考虑的因素" class="headerlink" title="特征要考虑的因素"></a>特征要考虑的因素</h2><p>挑选入模变量过程是个比较复杂的过程，需要考虑的因素很多，比如：<br>变量的预测能力（最主要和最直接的衡量标准）<br>变量之间的相关性<br>变量的简单性（容易生成和使用）<br>变量的强壮性（不容易被绕过）<br>变量在业务上的可解释性（被挑战时可以解释的通）等等</p>
<h2 id="特征的分类"><a href="#特征的分类" class="headerlink" title="特征的分类"></a>特征的分类</h2><p>根据不同的分类方法，可以将特征分为：<br>(1) 原始特征和高级特征。<br>(2) 非实时特征和实时特征。<br>(3) 离散值特征和连续值特征。</p>
<p>原始特征和高级特征——<br>原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征，图像特征中的像素点，用户性别等。高级特征是结合部分业务逻辑或者规则、模型，经过较复杂的处理，得到的特征，例如骑手达人分，模型打分等特征。</p>
<p>非实时特征和实时特征——<br>非实时特征是变化频率 (更新频率) 较少的特征，例如骑手平均速度，餐品单价等，在较长的时间段内都不会发生变化。实时特征是更新变化比较频繁的特征，是实时或准实时计算得到的特征，例如 5 分钟之内的骑行速度，半小时的跑单量等。</p>
<p>离散值特征和连续值特征——<br>离散值特征主要是特征有固定个数个可能值，例如今天周几，只有 7 个可能值：周 1，周 2，…，周日。离散值特征包括二值特征，例如今天是不是周末，只有 2 个可能值：是，否。连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征，特征取值为是 0~ 正无穷。</p>
<h2 id="特征工程的构成"><a href="#特征工程的构成" class="headerlink" title="特征工程的构成"></a>特征工程的构成</h2><p>特征工程是一个超集，一般认为包括特征构建、特征提取、特征选择三个部分。</p>
<p>在介绍这三部分之前，先介绍下特征升维。在机器学习中，有一个 VC 维理论。根据 VC 维理论，VC 维越高，打散能力越强，可容许的模型复杂度越高。在低维不可分的数据，映射到高维是可分。想象给你一堆物品，人脑是如何对这些物品进行分类？大脑依然是找出这些物品的一些特征，例如：颜色，形状，大小，触感等等，然后根据这些特征对物品做以归类，这其实就是一个先升维，后划分的过程。比如我们人脑识别香蕉。可能首先我们发现香蕉是黄色的。这是在颜色这个维度的一个切分。但是很多东西都是黄色的啊，例如哈密瓜。那么怎么区分香蕉和哈密瓜呢？我们发现香蕉形状是弯曲的。而哈密瓜是圆形的，那么我们就可以用形状来把香蕉和哈密瓜划分开了，即引入一个新维度——形状来区分。这就是一个从 “颜色” 一维特征升维到二维特征的例子。</p>
<p>那么问题来了，既然升维后模型能力能变强，是不是特征维度越高越好呢？<br>答案是否定的，因为：</p>
<ol>
<li>特征维数越高，模型越容易过拟合，此时更复杂的模型就不好用。</li>
<li>相互独立的特征维数越高，在测试集上达到相同的效果表现所需要的训练样本的数目就越大。在机器学习中，有一个非常经典的维度灾难的概念。用来描述当空间维度增加时，分析和组织高维空间，因体积指数增加而遇到各种问题场景。例如，100 个平均分布的点能把一个单位区间以每个点距离不超过 0.01 采样；而当维度增加到 10 后，如果以相邻点距离不超过 0.01 小方格采样单位超一单位超正方体，则需要 10^20 个采样点。</li>
<li>特征数量增加带来的训练、测试以及存储的开销都会增大。</li>
<li>在某些模型中，例如基于距离计算的模型 KMeans，KNN 等模型，在进行距离计算时，维度过高会影响精度和性能。</li>
<li>可视化分析的需要。在低维的情况下，例如二维，三维，我们可以把数据绘制出来，可视化地看到数据。当维度增高时，就难以绘制出来了。</li>
</ol>
<p>正是由于高维特征有如上描述的各种各样的问题，所以我们需要进行特征降维。特征降维的目标是将高维空间中的数据集映射到低维空间数据，同时尽可能少地丢失信息，或者降维后的数据点尽可能地容易被区分。</p>
<p>降维的方法又可以分为通过特征转换和直接在已有的特征里面选择两种方式。为了便于区分，于是我们把升维的过程称为特征构建，把通过特征转换来降维的过程称为特征提取，把直接从已有特征里面挑选的降维过程称为特征选择。</p>
<p>特征构建是指从原始数据中人工的找出一些具有物理意义的特征的过程。<br>特征构建比较麻烦，需要一定的经验，需要结合具体的业务，花费大量的时间去观察原始数据，思考问题的潜在形式和数据结构，以及如何将特征数据输入给预测算法。</p>
<p>前面我们说过，特征构建是一个升维的过程。但是同一个维度，有不同的方法。举个栗子， 假设你的数据里现在有一个颜色的维度，比如是 “item_Color”，它的三个取值分别是：red、blue、unknown。从特征构建的角度来看，你可以将其转化成一个二值特征 “has_color”，取值为 1 或 0。其中 1 表示有颜色，0 表示没颜色。你还可以将其转换成三个二值属性：Is_Red， Is_Blue and Is_Unknown。这取决于你的业务是否对其中的某一种颜色很敏感。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>既然特征构建是一个升维的过程，那么就需要找到各种不同的维度，以及这些维度上的值。<br>最直观的就是遍历——<br>对于表格数据：<br>通常把与业务相关的列列举出来，比如要预测房价则需要把房价面积、距离地铁口多远等信息列举出来；比如要预测西瓜是否是一个好瓜，要把瓜蒂形状、颜色、敲声等列举出来。<br>对于自然语言数据：<br>一般计算词频（term frequency，TF）和逆向文件频率（inverse document frequency，IDF），一个词语在一篇文章中出现次数越多, 同时在所有文档中出现次数越少, 越能够代表该文章。 Sklearn 和 spark mllib 都有很多包实现了 TF-IDF。<br>对于图像处理：<br>一般是通过通过图片的像素，通过滤波器等手段，提取出边缘、线等。<br>对于其他数据：<br>例如机器视觉、语音识别等，通常使用的是深度学习的算法，这些深度学习算法会自己进行特征学习，一般不需要人工手动构建特征。</p>
<p>此外，属性分割和结合是特征构建时常使用的方法——<br>结构性的表格数据，可以尝试组合二个、三个不同的属性构造新的特征，例如最近 5 天的平均值、最近 10 天的平均值；也可以把一个属性分解或切分，例如时间可以切分成上午、下午、晚上、周末等。<br>自然语言处理则使用词向量 Word2vec。<br>机器视觉则使用卷积核。</p>
<h2 id="对表格数据的预处理"><a href="#对表格数据的预处理" class="headerlink" title="对表格数据的预处理"></a>对表格数据的预处理</h2><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><p>当模型不能使用全部的数据来训练时，需要对数据进行采样，设定一定的采样率。采样的方法包括随机采样，固定比例采样等方法。<br>对于分类问题：选取正例，负例。正负样本比例不宜相差过大。还有一种数据不平衡处理之 SMOTE 算法 (from imblearn.combine import SMOTEENN)，SMOTE 算法的基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中。<br>对于回归问题，需要采集数据。对于采样得到的样本，根据需要设定样本权重。</p>
<h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><p>有些算法对缺失值不敏感，比如 xgboost；而有些则不能有缺失值，例如 LR。<br>如果某个变量缺失度比较高，那么可以直接剔除这个变量；否则按下面的方式来处理：</p>
<h4 id="缺失类型"><a href="#缺失类型" class="headerlink" title="缺失类型"></a>缺失类型</h4><p>(1) 完全随机缺失：缺失值跟其他变量无关，例如婚姻状况的缺失<br>(2)随机缺失：缺失值依赖于其他变量，例如 “配偶姓名” 的缺失取决于“婚姻状况”<br>(3) 完全非随机缺失：缺失值依赖于自己，例如高收入人群不愿易提供家庭收入处理方法</p>
<h4 id="连续变量缺失值的处理"><a href="#连续变量缺失值的处理" class="headerlink" title="连续变量缺失值的处理"></a>连续变量缺失值的处理</h4><ol>
<li>对于完全随机缺失，当缺失率不高时，可以：<br>(1) 用常数补缺，例如均值 特别地，如果存在极端值，要考虑是否剔除极端值后再计算均值； 例如 spark mllib 的 imputer(from pyspark.ml.feature import Imputer) 就是取均值。<br>(2) 从非缺失值中随机抽样赋予缺失样本。</li>
<li>对于随机缺失，可以在同一层内，用完全随机缺失的方法进行补缺</li>
<li>对于完全非随机缺失，可以当成一种属性，将该变量转化成类别变量<br>(1) 直接进行二值化，将该特征数据分为缺失值和非缺失值两类 (2) 考虑给定一个 step(比如 age，我们可以考虑每隔 2/3 岁为一个步长)，然后把它离散化，之后把 NaN 作为一个 type 加到属性类目中。</li>
</ol>
<h4 id="类别变量缺失值的处理"><a href="#类别变量缺失值的处理" class="headerlink" title="类别变量缺失值的处理"></a>类别变量缺失值的处理</h4><p>(1) 最常出现的类别补缺<br>(2) 从其他已知的样本中随机抽样进行补缺</p>
<h3 id="离群值"><a href="#离群值" class="headerlink" title="离群值"></a>离群值</h3><p>离群值又称极端值，往往会扭曲预测结果并影响模型精度，尤其在回归模型（线性回归，广义线性回归）中。因此，使用这种模型时我们需要对其进行检测和处理。如果要保留这些极端值，可以选择对极端值不敏感的模型，例如 KNN，决策树。<br>另外，如果变量取值变化小、比较平均，那么这样的特征对模型没什么贡献，也可以剔除掉。<br>统计上通常用 3-sigma 方法（一般来说，如果某个特征数据，最大值为 maxValue，均值为 mean，标准差为 std。如果满足 maxValue&gt;mean+3*std，那么我们就认为这个特征数据存在离群点）检测离群值。<br>另外还有一些根据距离来检测的算法，例如 spark-stochastic-outlier-selection(该方法对于数据量很大时，并不友好) 等。</p>
<h3 id="日期-时间型变量"><a href="#日期-时间型变量" class="headerlink" title="日期 / 时间型变量"></a>日期 / 时间型变量</h3><ol>
<li>转为二值型，例如判断时间是否为一个节日、是否是周末、是否是高峰期等</li>
<li>转为离散型，例如将一天分为 24 小时、或者上午下午晚上</li>
<li>基于某个基准日期，转化为距离这一天的天数</li>
<li>与其他特征组合，例如前半个小时某个事件发生了多少次</li>
</ol>
<h3 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h3><p>在建模中，需要对连续变量离散化。特征离散化后，模型会更稳定，降低了模型过拟合的风险。首先需要把这个变量进行分组处理（也叫离散化、分箱等等，说的都是一个意思）。</p>
<h4 id="无监督分箱法：等距划分、等频划分："><a href="#无监督分箱法：等距划分、等频划分：" class="headerlink" title="无监督分箱法：等距划分、等频划分："></a>无监督分箱法：等距划分、等频划分：</h4><p>等距划分：<br>从最小值到最大值之间，均分为 N 等份， 这样， 如果 A，B 为最小最大值， 则每个区间的长度为 W=(B−A)/N ， 则区间边界值为 A+W，A+2W，….A+(N−1)W 。这里只考虑边界，每个等份里面的实例数量可能不等。<br>等频划分：<br>区间的边界值要经过选择，使得每个区间包含大致相等的实例数量。比如说 N=10 ，每个区间应该包含大约 10% 的实例。<br>以上两种算法的弊端：<br>比如，等宽区间划分，划分为 5 区间，最高工资为 50000，则所有工资低于 10000 的人都被划分到同一区间。等频区间可能正好相反，所有工资高于 50000 的人都会被划分到 50000 这一区间中。这两种算法都忽略了实例所属的类型，落在正确区间里的偶然性很大。</p>
<h4 id="有监督的卡方分箱法-ChiMerge-："><a href="#有监督的卡方分箱法-ChiMerge-：" class="headerlink" title="有监督的卡方分箱法 (ChiMerge)："></a>有监督的卡方分箱法 (ChiMerge)：</h4><p>卡方检验针对分类变量。<br>卡方检验就是统计样本的实际观测值与理论推断值之间的偏离程度，实际观测值与理论推断值之间的偏离程度就决定卡方值的大小，卡方值越大，越不符合；卡方值越小，偏差越小，越趋于符合，若两个值完全相等时，卡方值就为 0，表明理论值完全符合。例如 spark mllib 里面的 ChiSquareTest (from pyspark.ml.stat import ChiSquareTest)。<br>ChiMerge 算法推荐使用 0.90、0.95、0.99 置信度，最大区间数取 10 到 15 之间，置信度取 0.90 时意味着：类别和属性独立时，有 90% 的可能性计算得到的卡方值会小于 4.6。 大于阈值 4.6 的卡方值就说明属性和类不是相互独立的，不能合并。</p>
<p>我们对特征进行分箱后，需要对分箱后的每组（箱）进行 woe 编码，然后才能放进模型训练。<br>WOE(weight of evidence, 证据权重)，一种有监督的编码方式，将预测类别的集中度的属性作为编码的数值。<br>经验上讲，WOE 的绝对值波动范围在 0.1~3 之间具有业务含义。</p>
<p>但是 WOE 不能体现变量当前分组中个体的数量占整体个体数量的比例对变量预测能力的影响。所以又提出了一个 IV。<br>IV(Information Value)，衡量特征包含预测变量浓度的一种指标<br>特征分箱越细，IV 越高。常用的阈值有: &lt;=0.02: 没有预测性，不可用；0.02 to 0.1: 弱预测性；0.1 to 0.2: 有一定的预测性；0.2 +: 高预测性</p>
<h3 id="对类别型变量编码"><a href="#对类别型变量编码" class="headerlink" title="对类别型变量编码"></a>对类别型变量编码</h3><h4 id="dummy-编码"><a href="#dummy-编码" class="headerlink" title="dummy 编码"></a>dummy 编码</h4><p>当自变量中存在无序多分类的变量时，例如 血型 A B AB O，因为它们之间不存在等级关系，所以在引入回归时，不能直接用 1、2、3、4 来表示，需要将血型转化为哑变量，并且要设置一个参照。虚拟编码使用 0 或 1 来表达所有类别的必要信息，这些取值并不代表数量的大小，仅仅表示不同的类别。例如 sklearn 中的 dummy.DummyClassifier<br>这个例子中用三位数来编码，第一位为 1 表示是 A 型 第二位为 1 表示 B 型 第三位为 1 表示 AB 型，那么 A 型的编码为 100，B 型的编码为 010，AB 型的编码为 001，O 型自动编码为 000。<br>若是 A B AB 对某疾病的影响差不多，那么可以用一个数字来编码，1 代表 A B AB 的分类，0 代表 O 型血。<br>所以 dummy 编码的作用是将不能够定量处理的变量量化，同时方便模型丢掉一些没用的特征。</p>
<h4 id="one-hot-编码"><a href="#one-hot-编码" class="headerlink" title="one-hot 编码"></a>one-hot 编码</h4><p>第一个特征两种值 (0: 10, 1: 01)，第二个特征三种值(0: 100, 1: 010, 2: 001)，第三个特征四种值(0: 1000, 1: 0100, 2: 0010, 3: 0001)。所以转换[0, 1, 3] 为[ 1., 0., 0., 1., 0., 0., 0., 0., 1.]。例如 sklearn 中的 preprocessing.OneHotEncoder 和 spark mllib 中的 OneHotEncoderEstimator。<br>树模型不太需要独热编码。<br>作用 1，使用 one-hot 编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算。<br>作用 2，几个特征合并到一个特征，达到降维的目的。</p>
<h3 id="归一化-标准化-正则化"><a href="#归一化-标准化-正则化" class="headerlink" title="归一化 / 标准化 / 正则化"></a>归一化 / 标准化 / 正则化</h3><h4 id="归一化（Normalization）"><a href="#归一化（Normalization）" class="headerlink" title="归一化（Normalization）"></a>归一化（Normalization）</h4><p>基于参数的模型或基于距离的模型，都要进行特征的归一化。</p>
<ol>
<li>把数据变为（0，1）之间的小数。主要是为了方便数据处理，因为将数据映射到 0 ～ 1 范围之内，可以使处理过程更加便捷、快速。</li>
<li>把有量纲表达式变换为无量纲表达式，成为纯量。经过归一化处理的数据，处于同一数量级，可以消除指标之间的量纲和量纲单位的影响，提高不同数据指标之间的可比性。<br>主要算法：</li>
<li>线性转换，即 min-max 归一化（常用方法）<br>y=(x-min)/(max-min)</li>
<li>对数函数转换<br>y=log10(x)</li>
<li>反余切函数转换<br>y=atan(x)*2/PI</li>
</ol>
<h4 id="标准化（Standardization）"><a href="#标准化（Standardization）" class="headerlink" title="标准化（Standardization）"></a>标准化（Standardization）</h4><p>数据的标准化是将数据按比例缩放，使之落入一个小的特定区间。<br>主要方法：<br>1.z-score 标准化，即零 - 均值标准化（常用方法）<br>y=(x-μ)/σ<br>是一种统计的处理，基于正态分布的假设，将数据变换为均值为 0、标准差为 1 的标准正态分布。但即使数据不服从正态分布，也可以用此法。特别适用于数据的最大值和最小值未知，或存在孤立点。</p>
<ol>
<li>对数 Logistic 模式<br>y=1/(1+e^(-x))</li>
</ol>
<h4 id="正则化（Regularization）"><a href="#正则化（Regularization）" class="headerlink" title="正则化（Regularization）"></a>正则化（Regularization）</h4><p>用一组与原不适定问题相 “邻近” 的适定问题的解，去逼近原问题的解，这种方法称为正则化方法。如何建立有效的正则化方法是反问题领域中不适定问题研究的重要内容。通常的正则化方法有基于变分原理的 Tikhonov 正则化、各种迭代方法以及其它的一些改进方法。</p>
<p>总的来说，归一化是为了消除不同数据之间的量纲，方便数据比较和共同处理，比如在神经网络中，归一化可以加快训练网络的收敛性；标准化是为了方便数据的下一步处理，而进行的数据缩放等变换，并不是为了方便与其他数据一同处理或比较，比如数据经过零 - 均值标准化后，更利于使用标准正态分布的性质，进行处理；正则化而是利用先验知识，在处理过程中引入正则化因子 (regulator)，增加引导约束的作用，比如在逻辑回归中使用正则化，可有效降低过拟合的现象。</p>
<p>通过特征转换，将原始特征转换为新的具有明显物理意义或者统计意义或核的特征的过程，从而达到降维的效果。</p>
<h2 id="特征提取的作用"><a href="#特征提取的作用" class="headerlink" title="特征提取的作用"></a>特征提取的作用</h2><p>特征提取是通过特征转换，自动地对原始观测降维，使其特征集合小到可以进行建模的过程。<br>特征提取有时能发现更有意义的特征属性。<br>对于表格式数据，可以使用主成分分析 (Principal Component Analysis)、聚类等映射方法；<br>对于图像数据，可以进行线 (line) 或边缘 (edge) 的提取；<br>根据相应的领域，图像、视频和音频数据可以有很多数字信号处理的方法对其进行处理。</p>
<h2 id="特征提取常用方法"><a href="#特征提取常用方法" class="headerlink" title="特征提取常用方法"></a>特征提取常用方法</h2><h3 id="PCA-Principal-component-analysis，主成分分析"><a href="#PCA-Principal-component-analysis，主成分分析" class="headerlink" title="PCA (Principal component analysis，主成分分析)"></a>PCA (Principal component analysis，主成分分析)</h3><p>PCA 的思想是通过坐标轴转换，寻找数据分布的最优子空间，从而达到降维、去相关的目的。<br>在数学上，是先用原始数据协方差矩阵的前 N 个最大特征值对应的特征向量构成映射矩阵，然后原始矩阵左乘映射矩阵，从而对原始数据降维。<br>PCA 算法：通过协方差矩阵的特征值分解能够得到数据的主成分，以二维特征为例，两个特征之间可能存在线性关系（例如运动的时速和秒速度），这样就造成了第二维信息是冗余的。PCA 的目标是发现这种特征之间的线性关系，并去除。例如 sklearn 的 decomposition.PCA 和 spark mllib 的 from pyspark.ml.feature import PCA</p>
<h3 id="LDA-Linear-Discriminant-Analysis，线性判别分析"><a href="#LDA-Linear-Discriminant-Analysis，线性判别分析" class="headerlink" title="LDA (Linear Discriminant Analysis，线性判别分析)"></a>LDA (Linear Discriminant Analysis，线性判别分析)</h3><p>LDA 的原理是将带上标签的数据（点），通过投影的方法，投影到维度更低的空间，使得投影后的点，会形成按类别区分，相同类别的点，将会在投影后更接近，不同类别的点距离越远。<br>LDA 算法：考虑 label，降维后的数据点尽可能地容易被区分。例如 sklearn 中的 lda.LDA，不过 LDA 在许多算法里面都要被删除，不使用了。</p>
<h3 id="ICA-Independent-component-analysis，独立成分分析"><a href="#ICA-Independent-component-analysis，独立成分分析" class="headerlink" title="ICA(Independent component analysis，独立成分分析)"></a>ICA(Independent component analysis，独立成分分析)</h3><p>ICA 认为观测到数据矩阵 X 是可以由未知的独立元举证 S 与未知的矩阵 A 相乘得到。ICA 希望通过矩阵 X 求得一个分离矩阵 W，使得 W 作用在 X 上所获得的矩阵 Y 能够逼近独立源矩阵 S，最后通过独立元矩阵 S 表示矩阵 X，所以说 ICA 独立成分分析提取出的特征中的独立部分。例如 sklearn 中的 decomposition.FastICA。<br>PCA 特征转换降维，提取的是不相关的部分，ICA 独立成分分析，获得的是相互独立的属性。</p>
<p>特征选择是剔除不相关或者冗余的特征的过程，从而达到减少有效特征的个数，减少模型训练的时间，提高模型的精确度的效果。</p>
<h2 id="特征选择主要有两个功能"><a href="#特征选择主要有两个功能" class="headerlink" title="特征选择主要有两个功能"></a>特征选择主要有两个功能</h2><ol>
<li>减少特征数量、降维，使模型泛化能力更强</li>
<li>减少过拟合，增强对特征和特征值之间的理解</li>
</ol>
<h2 id="与特征提取的区别"><a href="#与特征提取的区别" class="headerlink" title="与特征提取的区别"></a>与特征提取的区别</h2><ol>
<li>特征提取通过特征转换实现降维，特征选择则是依靠统计学方法或者于机器学习模型本身的特征选择（排序）功能实现降维。</li>
<li>特征选择是个重复迭代的过程。</li>
</ol>
<p>判别特征的重要性是对特征进行选择的预先指标，特征根据重要性被分配分数，然后根据分数不同进行排序，其中高分的特征被选择出来放入训练数据集。</p>
<h2 id="有效性分析"><a href="#有效性分析" class="headerlink" title="有效性分析"></a>有效性分析</h2><p>对特征的有效性进行分析，得到各个特征的特征权重，根据是否与模型有关可以分为</p>
<h3 id="1-与模型相关特征权重。"><a href="#1-与模型相关特征权重。" class="headerlink" title="1. 与模型相关特征权重。"></a>1. 与模型相关特征权重。</h3><p>使用所有的特征数据训练出来模型，看在模型中各个特征的权重，由于需要训练出模型，模型相关的权重与此次学习所用的模型比较相关。不同的模型有不同的模型权重衡量方法。例如线性模型中，特征的权重系数等。</p>
<h3 id="2-与模型无关特征权重。"><a href="#2-与模型无关特征权重。" class="headerlink" title="2. 与模型无关特征权重。"></a>2. 与模型无关特征权重。</h3><p>主要分析特征与 label 的相关性，这样的分析是与这次学习所使用的模型无关的。与模型无关特征权重分析方法包括 (1) 交叉熵，(2)Information Gain，(3)Odds ratio，(4)互信息，(5)KL 散度等</p>
<h2 id="具体的方法"><a href="#具体的方法" class="headerlink" title="具体的方法"></a>具体的方法</h2><h3 id="1-去掉取值变化小的特征"><a href="#1-去掉取值变化小的特征" class="headerlink" title="1 去掉取值变化小的特征"></a>1 去掉取值变化小的特征</h3><p>假设某特征的特征值只有 0 和 1，并且在所有输入样本中，95% 的实例的该特征取值都是 1，那就可以认为这个特征作用不大。如果 100% 都是 1，那这个特征就没意义了。当特征值都是离散型变量的时候这种方法才能用，如果是连续型变量，就需要将连续变量离散化之后才能用。</p>
<h3 id="2-单变量特征选择"><a href="#2-单变量特征选择" class="headerlink" title="2 单变量特征选择"></a>2 单变量特征选择</h3><p>单变量特征选择能够对每一个特征进行测试，衡量该特征和响应变量之间的关系，根据得分扔掉不好的特征。<br>在单因子分析中，如果某个变量对目标变量影响不大甚至完全独立，那么可以去掉这个变量。 如果两个变量相关性很高，其中一个变量解释性比较高，另外一个变量解释性比较低时，即使解释性比较低的变量效果更好一些，我们也会将其去掉，保留解释性比较高的那个变量。当然这是在回归模型中（奇异性问题）。其他模型不需要剔除。</p>
<h4 id="2-1-Pearson-相关系数-Pearson-Correlation"><a href="#2-1-Pearson-相关系数-Pearson-Correlation" class="headerlink" title="2.1 Pearson 相关系数 Pearson Correlation"></a>2.1 Pearson 相关系数 Pearson Correlation</h4><p>能帮助理解特征和响应变量之间关系的方法，该方法衡量的是变量之间的线性相关性，结果的取值区间为 [-1，1]，-1 表示完全的负相关(这个变量下降，那个就会上升)，+1 表示完全的正相关，0 表示没有线性相关。Sklearn 提供的 f_regrssion 方法能够批量计算特征的 p-value；pandas 的 df.corr() 和 spark mllib 的 Correlation.corr()也能够获取 pearson 相关系数。</p>
<h4 id="2-2-互信息和最大信息系数-Mutual-information-and-maximal-information-coefficient-MIC"><a href="#2-2-互信息和最大信息系数-Mutual-information-and-maximal-information-coefficient-MIC" class="headerlink" title="2.2 互信息和最大信息系数 Mutual information and maximal information coefficient (MIC)"></a>2.2 互信息和最大信息系数 Mutual information and maximal information coefficient (MIC)</h4><h4 id="2-3-距离相关系数-Distance-correlation"><a href="#2-3-距离相关系数-Distance-correlation" class="headerlink" title="2.3 距离相关系数 (Distance correlation)"></a>2.3 距离相关系数 (Distance correlation)</h4><p>距离相关系数是为了克服 Pearson 相关系数的弱点而生的。在 x 和 x^2 这个例子中，即便 Pearson 相关系数是 0，我们也不能断定这两个变量是独立的（有可能是非线性相关）；但如果距离相关系数是 0，那么我们就可以说这两个变量是独立的。</p>
<h4 id="2-4-基于学习模型的特征排序-Model-based-ranking"><a href="#2-4-基于学习模型的特征排序-Model-based-ranking" class="headerlink" title="2.4 基于学习模型的特征排序 (Model based ranking)"></a>2.4 基于学习模型的特征排序 (Model based ranking)</h4><p>例如 sklearn 中的 regr.feature<em>importances</em> 和 xgboost 的 bst.get_fscore(fmap=’xgb.fmap’)</p>
<h3 id="3-线性模型和正则化"><a href="#3-线性模型和正则化" class="headerlink" title="3 线性模型和正则化"></a>3 线性模型和正则化</h3><p>在很多实际的数据当中，往往存在多个互相关联的特征，这时候模型就会变得不稳定，数据中细微的变化就可能导致模型的巨大变化（模型的变化本质上是系数，或者叫参数，可以理解成 W），这会让模型的预测变得困难，这种现象也称为多重共线性。例如，假设我们有个数据集，它的真实模型应该是 Y=X1+X2，当我们观察的时候，发现 Y’=X1+X2+e，e 是噪音。如果 X1 和 X2 之间存在线性关系，例如 X1 约等于 X2，这个时候由于噪音 e 的存在，我们学到的模型可能就不是 Y=X1+X2 了，有可能是 Y=2X1，或者 Y=-X1+3X2。</p>
<h4 id="3-1-正则化模型"><a href="#3-1-正则化模型" class="headerlink" title="3.1 正则化模型"></a>3.1 正则化模型</h4><p>正则化就是把额外的约束或者惩罚项加到已有模型（损失函数）上，以防止过拟合并提高泛化能力。损失函数由原来的 E(X，Y) 变为 E(X，Y)+alpha||w||，w 是模型系数组成的向量（有些地方也叫参数 parameter，coefficients），||•|| 一般是 L1 或者 L2 范数，alpha 是一个可调的参数，控制着正则化的强度。当用在线性模型上时，L1 正则化和 L2 正则化也称为 Lasso 和 Ridge。</p>
<h4 id="3-2-L1-正则化-Lasso"><a href="#3-2-L1-正则化-Lasso" class="headerlink" title="3.2 L1 正则化 / Lasso"></a>3.2 L1 正则化 / Lasso</h4><p>L1 正则化将系数 w 的 l1 范数作为惩罚项加到损失函数上，由于正则项非零，这就迫使那些弱的特征所对应的系数变成 0。因此 L1 正则化往往会使学到的模型很稀疏（系数 w 经常为 0），这个特性使得 L1 正则化成为一种很好的特征选择方法。<br>如果继续增加 alpha 的值，得到的模型就会越来越稀疏，即越来越多的特征系数会变成 0。然而，L1 正则化像非正则化线性模型一样也是不稳定的，如果特征集合中具有相关联的特征，当数据发生细微变化时也有可能导致很大的模型差异。</p>
<h4 id="3-3-L2-正则化-Ridge-regression"><a href="#3-3-L2-正则化-Ridge-regression" class="headerlink" title="3.3 L2 正则化 / Ridge regression"></a>3.3 L2 正则化 / Ridge regression</h4><p>L2 正则化将系数向量的 L2 范数添加到了损失函数中。由于 L2 惩罚项中系数是二次方的，这使得 L2 和 L1 有着诸多差异，最明显的一点就是，L2 正则化会让系数的取值变得平均。对于关联特征，这意味着他们能够获得更相近的对应系数。还是以 Y=X1+X2 为例，假设 X1 和 X2 具有很强的关联，如果用 L1 正则化，不论学到的模型是 Y=X1+X2 还是 Y=2X1，惩罚都是一样的，都是 2alpha。但是对于 L2 来说，第一个模型的惩罚项是 2alpha，但第二个模型的是 4*alpha。可以看出，系数之和为常数时，各系数相等时惩罚是最小的，所以才有了 L2 会让各个系数趋于相同的特点。</p>
<h3 id="4-随机森林"><a href="#4-随机森林" class="headerlink" title="4 随机森林"></a>4 随机森林</h3><p>随机森林具有准确率高、鲁棒性好、易于使用等优点，这使得它成为了目前最流行的机器学习算法之一。随机森林提供了两种特征选择的方法：mean decrease impurity 和 mean decrease accuracy。</p>
<h4 id="4-1-平均不纯度减少-mean-decrease-impurity"><a href="#4-1-平均不纯度减少-mean-decrease-impurity" class="headerlink" title="4.1 平均不纯度减少 mean decrease impurity"></a>4.1 平均不纯度减少 mean decrease impurity</h4><p>随机森林由多个决策树构成。决策树中的每一个节点都是关于某个特征的条件，为的是将数据集按照不同的响应变量一分为二。利用不纯度可以确定节点（最优条件），对于分类问题，通常采用基尼不纯度或者信息增益，对于回归问题，通常采用的是方差或者最小二乘拟合。当训练决策树的时候，可以计算出每个特征减少了多少树的不纯度。对于一个决策树森林来说，可以算出每个特征平均减少了多少不纯度，并把它平均减少的不纯度作为特征选择的值。</p>
<h4 id="4-2-平均精确率减少-Mean-decrease-accuracy"><a href="#4-2-平均精确率减少-Mean-decrease-accuracy" class="headerlink" title="4.2 平均精确率减少 Mean decrease accuracy"></a>4.2 平均精确率减少 Mean decrease accuracy</h4><p>另一种常用的特征选择方法就是直接度量每个特征对模型精确率的影响。主要思路是打乱每个特征的特征值顺序，并且度量顺序变动对模型的精确率的影响。很明显，对于不重要的变量来说，打乱顺序对模型的精确率影响不会太大，但是对于重要的变量来说，打乱顺序就会降低模型的精确率。</p>
<h3 id="5-两种顶层特征选择算法"><a href="#5-两种顶层特征选择算法" class="headerlink" title="5 两种顶层特征选择算法"></a>5 两种顶层特征选择算法</h3><p>之所以叫做顶层，是因为他们都是建立在基于模型的特征选择方法基础之上的，例如回归和 SVM，在不同的子集上建立模型，然后汇总最终确定特征得分。</p>
<h4 id="5-1-稳定性选择-Stability-selection"><a href="#5-1-稳定性选择-Stability-selection" class="headerlink" title="5.1 稳定性选择 Stability selection"></a>5.1 稳定性选择 Stability selection</h4><p>稳定性选择是一种基于二次抽样和选择算法相结合较新的方法，选择算法可以是回归、SVM 或其他类似的方法。它的主要思想是在不同的数据子集和特征子集上运行特征选择算法，不断的重复，最终汇总特征选择结果，比如可以统计某个特征被认为是重要特征的频率（被选为重要特征的次数除以它所在的子集被测试的次数）。理想情况下，重要特征的得分会接近 100%。稍微弱一点的特征得分会是非 0 的数，而最无用的特征得分将会接近于 0。</p>
<h4 id="5-2-递归特征消除-Recursive-feature-elimination-RFE"><a href="#5-2-递归特征消除-Recursive-feature-elimination-RFE" class="headerlink" title="5.2 递归特征消除 Recursive feature elimination (RFE)"></a>5.2 递归特征消除 Recursive feature elimination (RFE)</h4><p>递归特征消除的主要思想是反复的构建模型（如 SVM 或者回归模型）然后选出最好的（或者最差的）的特征（可以根据系数来选），把选出来的特征放到一遍，然后在剩余的特征上重复这个过程，直到所有特征都遍历了。这个过程中特征被消除的次序就是特征的排序。因此，这是一种寻找最优特征子集的贪心算法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于理解数据、数据的结构、特点来说，单变量特征选择是个非常好的选择。尽管可以用它对特征进行排序来优化模型，但由于它不能发现冗余（例如假如一个特征子集，其中的特征之间具有很强的关联，那么从中选择最优的特征时就很难考虑到冗余的问题）。<br>正则化的线性模型对于特征理解和特征选择来说是非常强大的工具。L1 正则化能够生成稀疏的模型，对于选择特征子集来说非常有用；相比起 L1 正则化，L2 正则化的表现更加稳定，由于有用的特征往往对应系数非零，因此 L2 正则化对于数据的理解来说很合适。由于响应变量和特征之间往往是非线性关系，可以采用 basis expansion 的方式将特征转换到一个更加合适的空间当中，在此基础上再考虑运用简单的线性模型。<br>随机森林是一种非常流行的特征选择方法，它易于使用，一般不需要 feature engineering、调参等繁琐的步骤，并且很多工具包都提供了平均不纯度下降方法。它的两个主要问题，1 是重要的特征有可能得分很低（关联特征问题），2 是这种方法对特征变量类别多的特征越有利（偏向问题）。尽管如此，这种方法仍然非常值得在你的应用中试一试。<br>特征选择在很多机器学习和数据挖掘场景中都是非常有用的。在使用的时候要弄清楚自己的目标是什么，然后找到哪种方法适用于自己的任务。当选择最优特征以提升模型性能的时候，可以采用交叉验证的方法来验证某种方法是否比其他方法要好。当用特征选择的方法来理解数据的时候要留心，特征选择模型的稳定性非常重要，稳定性差的模型很容易就会导致错误的结论。对数据进行二次采样然后在子集上运行特征选择算法能够有所帮助，如果在各个子集上的结果是一致的，那就可以说在这个数据集上得出来的结论是可信的，可以用这种特征选择模型的结果来理解数据。</p>
<p>特征学习是在深度学习中，算法可以从原始数据中自动识别和使用特征。<br>现代深度学习方法在特征学习领域有很多成功案例，抽象的特征表达可以自动得到，但是你无法理解和利用这些学习得到的结果，只有黑盒的方式才可以使用这些特征。</p>
<p><img src="http://tech.dianwoda.com/content/images/2018/04/--------.jpg" alt> （不想画了，盗图）</p>
<p><a href="http://www.csuldw.com/2015/10/24/2015-10-24%20feature%20engineering/" target="_blank" rel="noopener">http://www.csuldw.com/2015/10/24/2015-10-24%20feature%20engineering/</a><br><a href="http://dataunion.org/14072.html" target="_blank" rel="noopener">http://dataunion.org/14072.html</a><br><a href="http://blog.csdn.net/u013421629/article/details/78416748" target="_blank" rel="noopener">http://blog.csdn.net/u013421629/article/details/78416748</a></p>

    </div>

    
    
    
        
      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>AILab-aida</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ailab-aida.github.io/2019/10/28/特征工程/" title="特征工程">https://ailab-aida.github.io/2019/10/28/特征工程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/算法/" rel="tag"># 算法</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/10/28/模型上线和 pmml 简介/" rel="next" title="模型上线和 pmml 简介">
                  <i class="fa fa-chevron-left"></i> 模型上线和 pmml 简介
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/28/机器学习在出餐时间预测上的探索/" rel="prev" title="机器学习在出餐时间预测上的探索">
                  机器学习在出餐时间预测上的探索 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#特征工程的意义"><span class="nav-number">1.</span> <span class="nav-text">特征工程的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征要考虑的因素"><span class="nav-number">2.</span> <span class="nav-text">特征要考虑的因素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征的分类"><span class="nav-number">3.</span> <span class="nav-text">特征的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征工程的构成"><span class="nav-number">4.</span> <span class="nav-text">特征工程的构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用方法"><span class="nav-number">5.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对表格数据的预处理"><span class="nav-number">6.</span> <span class="nav-text">对表格数据的预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#采样"><span class="nav-number">6.1.</span> <span class="nav-text">采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺失值"><span class="nav-number">6.2.</span> <span class="nav-text">缺失值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缺失类型"><span class="nav-number">6.2.1.</span> <span class="nav-text">缺失类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连续变量缺失值的处理"><span class="nav-number">6.2.2.</span> <span class="nav-text">连续变量缺失值的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类别变量缺失值的处理"><span class="nav-number">6.2.3.</span> <span class="nav-text">类别变量缺失值的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#离群值"><span class="nav-number">6.3.</span> <span class="nav-text">离群值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期-时间型变量"><span class="nav-number">6.4.</span> <span class="nav-text">日期 / 时间型变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据离散化"><span class="nav-number">6.5.</span> <span class="nav-text">数据离散化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#无监督分箱法：等距划分、等频划分："><span class="nav-number">6.5.1.</span> <span class="nav-text">无监督分箱法：等距划分、等频划分：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有监督的卡方分箱法-ChiMerge-："><span class="nav-number">6.5.2.</span> <span class="nav-text">有监督的卡方分箱法 (ChiMerge)：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对类别型变量编码"><span class="nav-number">6.6.</span> <span class="nav-text">对类别型变量编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dummy-编码"><span class="nav-number">6.6.1.</span> <span class="nav-text">dummy 编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#one-hot-编码"><span class="nav-number">6.6.2.</span> <span class="nav-text">one-hot 编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归一化-标准化-正则化"><span class="nav-number">6.7.</span> <span class="nav-text">归一化 / 标准化 / 正则化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#归一化（Normalization）"><span class="nav-number">6.7.1.</span> <span class="nav-text">归一化（Normalization）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标准化（Standardization）"><span class="nav-number">6.7.2.</span> <span class="nav-text">标准化（Standardization）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正则化（Regularization）"><span class="nav-number">6.7.3.</span> <span class="nav-text">正则化（Regularization）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征提取的作用"><span class="nav-number">7.</span> <span class="nav-text">特征提取的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征提取常用方法"><span class="nav-number">8.</span> <span class="nav-text">特征提取常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PCA-Principal-component-analysis，主成分分析"><span class="nav-number">8.1.</span> <span class="nav-text">PCA (Principal component analysis，主成分分析)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LDA-Linear-Discriminant-Analysis，线性判别分析"><span class="nav-number">8.2.</span> <span class="nav-text">LDA (Linear Discriminant Analysis，线性判别分析)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ICA-Independent-component-analysis，独立成分分析"><span class="nav-number">8.3.</span> <span class="nav-text">ICA(Independent component analysis，独立成分分析)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特征选择主要有两个功能"><span class="nav-number">9.</span> <span class="nav-text">特征选择主要有两个功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与特征提取的区别"><span class="nav-number">10.</span> <span class="nav-text">与特征提取的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有效性分析"><span class="nav-number">11.</span> <span class="nav-text">有效性分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-与模型相关特征权重。"><span class="nav-number">11.1.</span> <span class="nav-text">1. 与模型相关特征权重。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-与模型无关特征权重。"><span class="nav-number">11.2.</span> <span class="nav-text">2. 与模型无关特征权重。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具体的方法"><span class="nav-number">12.</span> <span class="nav-text">具体的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-去掉取值变化小的特征"><span class="nav-number">12.1.</span> <span class="nav-text">1 去掉取值变化小的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-单变量特征选择"><span class="nav-number">12.2.</span> <span class="nav-text">2 单变量特征选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Pearson-相关系数-Pearson-Correlation"><span class="nav-number">12.2.1.</span> <span class="nav-text">2.1 Pearson 相关系数 Pearson Correlation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-互信息和最大信息系数-Mutual-information-and-maximal-information-coefficient-MIC"><span class="nav-number">12.2.2.</span> <span class="nav-text">2.2 互信息和最大信息系数 Mutual information and maximal information coefficient (MIC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-距离相关系数-Distance-correlation"><span class="nav-number">12.2.3.</span> <span class="nav-text">2.3 距离相关系数 (Distance correlation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-基于学习模型的特征排序-Model-based-ranking"><span class="nav-number">12.2.4.</span> <span class="nav-text">2.4 基于学习模型的特征排序 (Model based ranking)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线性模型和正则化"><span class="nav-number">12.3.</span> <span class="nav-text">3 线性模型和正则化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-正则化模型"><span class="nav-number">12.3.1.</span> <span class="nav-text">3.1 正则化模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-L1-正则化-Lasso"><span class="nav-number">12.3.2.</span> <span class="nav-text">3.2 L1 正则化 / Lasso</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-L2-正则化-Ridge-regression"><span class="nav-number">12.3.3.</span> <span class="nav-text">3.3 L2 正则化 / Ridge regression</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-随机森林"><span class="nav-number">12.4.</span> <span class="nav-text">4 随机森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-平均不纯度减少-mean-decrease-impurity"><span class="nav-number">12.4.1.</span> <span class="nav-text">4.1 平均不纯度减少 mean decrease impurity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-平均精确率减少-Mean-decrease-accuracy"><span class="nav-number">12.4.2.</span> <span class="nav-text">4.2 平均精确率减少 Mean decrease accuracy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-两种顶层特征选择算法"><span class="nav-number">12.5.</span> <span class="nav-text">5 两种顶层特征选择算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-稳定性选择-Stability-selection"><span class="nav-number">12.5.1.</span> <span class="nav-text">5.1 稳定性选择 Stability selection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-递归特征消除-Recursive-feature-elimination-RFE"><span class="nav-number">12.5.2.</span> <span class="nav-text">5.2 递归特征消除 Recursive feature elimination (RFE)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">12.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="AILab-aida">
  <p class="site-author-name" itemprop="name">AILab-aida</p>
  <div class="site-description" itemprop="description">涉猎的主要编程语言为 深度学习、机器学习、大数据、服务端、移动端、前端、爬虫(go、scala、Java、flutter、Python、react、Vue)等。</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/qq1074123922" title="GitHub &rarr; https://github.com/qq1074123922" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="/1074123922@qq.com" title="E-Mail &rarr; 1074123922@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AILab-aida</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a6d340a24e0f5044ffc3',
      clientSecret: 'edff6432acd3e21caff2696cc123e15b3ca3461c',
      repo: 'ailab-aida.github.io',
      owner: 'AILab-aida',
      admin: ['ailab'],
      id: '054bb586ba9466e87634fb03ad81a7bd',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
