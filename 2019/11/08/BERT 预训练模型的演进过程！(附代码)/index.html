<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.4.0">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="AILab-aida" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: true,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="什么是 BERT BERT 的全称是 Bidirectional Encoder Representation from Transformers，是 Google2018 年提出的预训练模型，即双向 Transformer 的 Encoder，因为 decoder 是不能获要预测的信息的。模型的主要创新点都在 pre-train 方法上，即用了 Masked LM 和 Next Sentenc">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="BERT 预训练模型的演进过程！(附代码)">
<meta property="og:url" content="https://ailab-aida.github.io/2019/11/08/BERT 预训练模型的演进过程！(附代码)/index.html">
<meta property="og:site_name" content="AILab-aida">
<meta property="og:description" content="什么是 BERT BERT 的全称是 Bidirectional Encoder Representation from Transformers，是 Google2018 年提出的预训练模型，即双向 Transformer 的 Encoder，因为 decoder 是不能获要预测的信息的。模型的主要创新点都在 pre-train 方法上，即用了 Masked LM 和 Next Sentenc">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f7ae0e7b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f7f2fe1dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=W_t=%EF%BC%88Bert%EF%BC%89">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f846331b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f842e135b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f842e135b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f842e135b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7829014ca2884?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d782901f4875ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7829022159fa8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7829022088808?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7829030c16952?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d78290273ccc41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d782903b4227c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d782903ebac987?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d78290485bc245?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/26/16d6c63d2c5134b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/9/24/16d621b9608e9250?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2019-11-19T03:34:53.340Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BERT 预训练模型的演进过程！(附代码)">
<meta name="twitter:description" content="什么是 BERT BERT 的全称是 Bidirectional Encoder Representation from Transformers，是 Google2018 年提出的预训练模型，即双向 Transformer 的 Encoder，因为 decoder 是不能获要预测的信息的。模型的主要创新点都在 pre-train 方法上，即用了 Masked LM 和 Next Sentenc">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f7ae0e7b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
  <link rel="canonical" href="https://ailab-aida.github.io/2019/11/08/BERT 预训练模型的演进过程！(附代码)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>BERT 预训练模型的演进过程！(附代码) | AILab-aida</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AILab-aida</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一个专注技术的组织</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-sitemap">
      
    

    <a href="/atom.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/qq1074123922" class="github-corner" title="AILab-aida GitHub" aria-label="AILab-aida GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://ailab-aida.github.io/2019/11/08/BERT 预训练模型的演进过程！(附代码)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AILab-aida">
      <meta itemprop="description" content="涉猎的主要编程语言为 深度学习、机器学习、大数据、服务端、移动端、前端、爬虫(go、scala、Java、flutter、Python、react、Vue)等。">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AILab-aida">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">BERT 预训练模型的演进过程！(附代码)

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-08 11:50:05" itemprop="dateCreated datePublished" datetime="2019-11-08T11:50:05+08:00">2019-11-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 11:34:53" itemprop="dateModified" datetime="2019-11-19T11:34:53+08:00">2019-11-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深度学习/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ol>
<li>什么是 BERT</li>
</ol><hr><p><strong>BERT 的全称是 Bidirectional Encoder Representation from Transformers</strong>，是 Google2018 年提出的预训练模型，即双向 Transformer 的 Encoder，因为 decoder 是不能获要预测的信息的。模型的主要创新点都在 pre-train 方法上，即用了 Masked LM 和 Next Sentence Prediction 两种方法分别捕捉词语和句子级别的 representation。</p><a id="more"></a>


<p>Bert 最近很火，应该是最近最火爆的 AI 进展，网上的评价很高，那么 Bert 值得这么高的评价吗？我个人判断是值得。那为什么会有这么高的评价呢？是因为它有重大的理论或者模型创新吗？其实并没有，从模型创新角度看一般，创新不算大。但是架不住效果太好了，基本刷新了很多 NLP 的任务的最好性能，有些任务还被刷爆了，这个才是关键。另外一点是 Bert 具备广泛的通用性，就是说绝大部分 NLP 任务都可以采用类似的两阶段模式直接去提升效果，这个第二关键。客观的说，把 Bert 当做最近两年 NLP 重大进展的集大成者更符合事实。</p>
<ol>
<li>从 Word Embedding 到 Bert 模型的发展</li>
</ol>
<hr>
<h3 id="2-1-图像的预训练"><a href="#2-1-图像的预训练" class="headerlink" title="2.1 图像的预训练"></a>2.1 图像的预训练</h3><p>自从深度学习火起来后，预训练过程就是做图像或者视频领域的一种比较常规的做法，有比较长的历史了，而且这种做法很有效，能明显促进应用的效果。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f7ae0e7b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>那么图像领域怎么做预训练呢，上图展示了这个过程，</p>
<ol>
<li><p>我们设计好网络结构以后，对于图像来说一般是 CNN 的多层叠加网络结构，可以先用某个训练集合比如训练集合 A 或者训练集合 B 对这个网络进行预先训练，在 A 任务上或者 B 任务上学会网络参数，然后存起来以备后用。</p>
</li>
<li><p>假设我们面临第三个任务 C，网络结构采取相同的网络结构，在比较浅的几层 CNN 结构，网络参数初始化的时候可以加载 A 任务或者 B 任务学习好的参数，其它 CNN 高层参数仍然随机初始化。</p>
</li>
<li><p>之后我们用 C 任务的训练数据来训练网络，此时有两种做法：</p>
<p><strong>一种</strong>是浅层加载的参数在训练 C 任务过程中不动，这种方法被称为 “Frozen”;</p>
<p><strong>另一种</strong>是底层网络参数尽管被初始化了，在 C 任务训练过程中仍然随着训练的进程不断改变，这种一般叫 “Fine-Tuning”，顾名思义，就是更好地把参数进行调整使得更适应当前的 C 任务。</p>
</li>
</ol>
<p>一般图像或者视频领域要做预训练一般都这么做。这样做的优点是：如果手头任务 C 的训练集合数据量较少的话，利用预训练出来的参数来训练任务 C，加个预训练过程也能极大加快任务训练的收敛速度，所以这种预训练方式是老少皆宜的解决方案，另外疗效又好，所以在做图像处理领域很快就流行开来。</p>
<p><strong>为什么预训练可行</strong></p>
<p>对于层级的 CNN 结构来说，不同层级的神经元学习到了不同类型的图像特征，由底向上特征形成层级结构，所以预训练好的网络参数，尤其是底层的网络参数抽取出特征跟具体任务越无关，越具备任务的通用性，所以这是为何一般用底层预训练好的参数初始化新任务网络参数的原因。而高层特征跟任务关联较大，实际可以不用使用，或者采用 Fine-tuning 用新数据集合清洗掉高层无关的特征抽取器。</p>
<h3 id="2-2-Word-Embedding"><a href="#2-2-Word-Embedding" class="headerlink" title="2.2 Word Embedding"></a>2.2 Word Embedding</h3><p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f7f2fe1dd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>神经网络语言模型 (NNLM) 的思路。先说训练过程。学习任务是输入某个句中单词</p>
<p><img src="https://www.zhihu.com/equation?tex=W_t=%EF%BC%88Bert%EF%BC%89" alt></p>
<p>前面句子的 t-1 个单词，要求网络正确预测单词 Bert，即最大化：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f846331b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>前面任意单词</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>用 Onehot 编码（比如：0001000）作为原始单词输入，之后乘以矩阵 Q 后获得向量</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f842e135b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>，每个单词的</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f842e135b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>拼接，上接隐层，然后接 softmax 去预测后面应该后续接哪个单词。这个</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f842e135b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>是什么？这其实就是单词对应的 Word Embedding 值，那个矩阵 Q 包含 V 行，V 代表词典大小，每一行内容代表对应单词的 Word embedding 值。只不过 Q 的内容也是网络参数，需要学习获得，训练刚开始用随机值初始化矩阵 Q，当这个网络训练好之后，矩阵 Q 的内容被正确赋值，每一行代表一个单词对应的 Word embedding 值。所以你看，通过这个网络学习语言模型任务，这个网络不仅自己能够根据上文预测后接单词是什么，同时获得一个副产品，就是那个矩阵 Q，这就是单词的 Word Embedding。</p>
<p>2013 年最火的用语言模型做 Word Embedding 的工具是 Word2Vec，后来又出了 Glove，Word2Vec。对于这两个模型不熟悉的可以参考我之前的文章，这里不再赘述：</p>
<ul>
<li><a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/NLP/16.1%20Word%20Embedding" target="_blank" rel="noopener">Word2Vec</a></li>
<li><a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/NLP/16.3%20GloVe" target="_blank" rel="noopener">GloVe</a></li>
</ul>
<p>上面这种模型做法就是 18 年之前 NLP 领域里面采用预训练的典型做法，之前说过，Word Embedding 其实对于很多下游 NLP 任务是有帮助的，只是帮助没有大到闪瞎忘记戴墨镜的围观群众的双眼而已。那么新问题来了，为什么这样训练及使用 Word Embedding 的效果没有期待中那么好呢？答案很简单，因为 Word Embedding 有问题呗。这貌似是个比较弱智的答案，关键是 Word Embedding 存在什么问题？这其实是个好问题。</p>
<p><strong> 这片在 Word Embedding 头上笼罩了好几年的乌云是什么？是多义词问题。</strong> 我们知道，多义词是自然语言中经常出现的现象，也是语言灵活性和高效性的一种体现。多义词对 Word Embedding 来说有什么负面影响？如上图所示，比如多义词 Bank，有两个常用含义，但是 Word Embedding 在对 bank 这个单词进行编码的时候，是区分不开这两个含义的，因为它们尽管上下文环境中出现的单词不同，但是在用语言模型训练的时候，不论什么上下文的句子经过 word2vec，都是预测相同的单词 bank，而同一个单词占的是同一行的参数空间，这导致两种不同的上下文信息都会编码到相同的 word embedding 空间里去。所以 word embedding 无法区分多义词的不同语义，这就是它的一个比较严重的问题。</p>
<p>有没有简单优美的解决方案呢？ELMO 提供了一种简洁优雅的解决方案。</p>
<h3 id="2-3-ELMO"><a href="#2-3-ELMO" class="headerlink" title="2.3 ELMO"></a>2.3 ELMO</h3><p>ELMO 是 “Embedding from Language Models” 的简称，其实这个名字并没有反应它的本质思想，提出 ELMO 的论文题目：“Deep contextualized word representation”更能体现其精髓，而精髓在哪里？在 deep contextualized 这个短语，一个是 deep，一个是 context，其中 context 更关键。</p>
<p>在此之前的 Word Embedding 本质上是个静态的方式，所谓静态指的是训练好之后每个单词的表达就固定住了，以后使用的时候，不论新句子上下文单词是什么，这个单词的 Word Embedding 不会跟着上下文场景的变化而改变，所以对于比如 Bank 这个词，它事先学好的 Word Embedding 中混合了几种语义 ，在应用中来了个新句子，即使从上下文中（比如句子包含 money 等词）明显可以看出它代表的是 “银行” 的含义，但是对应的 Word Embedding 内容也不会变，它还是混合了多种语义。这是为何说它是静态的，这也是问题所在。</p>
<p><strong>ELMO 的本质思想是</strong>：我事先用语言模型学好一个单词的 Word Embedding，此时多义词无法区分，不过这没关系。在我实际使用 Word Embedding 的时候，单词已经具备了特定的上下文了，这个时候我可以根据上下文单词的语义去调整单词的 Word Embedding 表示，这样经过调整后的 Word Embedding 更能表达在这个上下文中的具体含义，自然也就解决了多义词的问题了。所以 ELMO 本身是个根据当前上下文对 Word Embedding 动态调整的思路。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7829014ca2884?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>ELMO 采用了典型的两阶段过程，第一个阶段是利用语言模型进行预训练；第二个阶段是在做下游任务时，从预训练网络中提取对应单词的网络各层的 Word Embedding 作为新特征补充到下游任务中。</p>
<p>上图展示的是其预训练过程，它的网络结构采用了双层双向 LSTM，目前语言模型训练的任务目标是根据单词</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>的上下文去正确预测单词</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>，</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>之前的单词序列 Context-before 称为上文，之后的单词序列 Context-after 称为下文。</p>
<p>图中左端的前向双层 LSTM 代表正方向编码器，输入的是从左到右顺序的除了预测单词外</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>的上文 Context-before；右端的逆向双层 LSTM 代表反方向编码器，输入的是从右到左的逆序的句子下文 Context-after；每个编码器的深度都是两层 LSTM 叠加。</p>
<p>这个网络结构其实在 NLP 中是很常用的。使用这个网络结构利用大量语料做语言模型任务就能预先训练好这个网络，如果训练好这个网络后，输入一个新句子</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d782901f4875ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>，句子中每个单词都能得到对应的三个 Embedding:</p>
<ul>
<li>最底层是单词的 Word Embedding；</li>
<li>往上走是第一层双向 LSTM 中对应单词位置的 Embedding，这层编码单词的句法信息更多一些；</li>
<li>再往上走是第二层 LSTM 中对应单词位置的 Embedding，这层编码单词的语义信息更多一些。</li>
</ul>
<p>也就是说，ELMO 的预训练过程不仅仅学会单词的 Word Embedding，还学会了一个双层双向的 LSTM 网络结构，而这两者后面都有用。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7829022159fa8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>上面介绍的是 ELMO 的第一阶段：预训练阶段。那么预训练好网络结构后，<strong>如何给下游任务使用呢</strong>？上图展示了下游任务的使用过程，比如我们的下游任务仍然是 QA 问题:</p>
<ol>
<li>此时对于问句 X，我们可以先将句子 X 作为预训练好的 ELMO 网络的输入，这样句子 X 中每个单词在 ELMO 网络中都能获得对应的三个 Embedding；</li>
<li>之后给予这三个 Embedding 中的每一个 Embedding 一个权重 a，这个权重可以学习得来，根据各自权重累加求和，将三个 Embedding 整合成一个；</li>
<li>然后将整合后的这个 Embedding 作为 X 句在自己任务的那个网络结构中对应单词的输入，以此作为补充的新特征给下游任务使用。对于上图所示下游任务 QA 中的回答句子 Y 来说也是如此处理。</li>
</ol>
<p>因为 ELMO 给下游提供的是每个单词的特征形式，所以这一类预训练的方法被称为 “Feature-based Pre-Training”。</p>
<p><strong>前面我们提到静态 Word Embedding 无法解决多义词的问题，那么 ELMO 引入上下文动态调整单词的 embedding 后多义词问题解决了吗？解决了，而且比我们期待的解决得还要好</strong>。对于 Glove 训练出的 Word Embedding 来说，多义词比如 play，根据它的 embedding 找出的最接近的其它单词大多数集中在体育领域，这很明显是因为训练数据中包含 play 的句子中体育领域的数量明显占优导致；而使用 ELMO，根据上下文动态调整后的 embedding 不仅能够找出对应的 “演出” 的相同语义的句子，而且还可以保证找出的句子中的 play 对应的词性也是相同的，这是超出期待之处。之所以会这样，是因为我们上面提到过，第一层 LSTM 编码了很多句法信息，这在这里起到了重要作用。</p>
<p><strong>ELMO 有什么值得改进的缺点呢</strong>？</p>
<ul>
<li>首先，一个非常明显的缺点在特征抽取器选择方面，ELMO 使用了 LSTM 而不是新贵 Transformer，Transformer 是谷歌在 17 年做机器翻译任务的 “Attention is all you need” 的论文中提出的，引起了相当大的反响，很多研究已经证明了 Transformer 提取特征的能力是要远强于 LSTM 的。如果 ELMO 采取 Transformer 作为特征提取器，那么估计 Bert 的反响远不如现在的这种火爆场面。</li>
<li>另外一点，ELMO 采取双向拼接这种融合特征的能力可能比 Bert 一体化的融合特征方式弱，但是，这只是一种从道理推断产生的怀疑，目前并没有具体实验说明这一点。</li>
</ul>
<h3 id="2-4-GPT"><a href="#2-4-GPT" class="headerlink" title="2.4 GPT"></a>2.4 GPT</h3><p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7829022088808?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>GPT 是 “Generative Pre-Training” 的简称，从名字看其含义是指的生成式的预训练。GPT 也采用两阶段过程，第一个阶段是利用语言模型进行预训练，第二阶段通过 Fine-tuning 的模式解决下游任务。</p>
<p>上图展示了 GPT 的预训练过程，其实和 ELMO 是类似的，主要不同在于两点：</p>
<ul>
<li>首先，特征抽取器不是用的 RNN，而是用的 Transformer，上面提到过它的特征抽取能力要强于 RNN，这个选择很明显是很明智的；</li>
<li>其次，GPT 的预训练虽然仍然是以语言模型作为目标任务，但是采用的是单向的语言模型，所谓 “单向” 的含义是指：语言模型训练的任务目标是根据 <img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt> 单词的上下文去正确预测单词 <img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt> ， <img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt> 之前的单词序列 Context-before 称为上文，之后的单词序列 Context-after 称为下文。</li>
</ul>
<p>如果对 Transformer 模型不太了解的，可以参考我写的文章：<a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/NLP/16.7%20Transformer" target="_blank" rel="noopener">Transformer</a></p>
<p>ELMO 在做语言模型预训练的时候，预测单词</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7828f83fcc154?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>同时使用了上文和下文，而 GPT 则只采用 Context-before 这个单词的上文来进行预测，而抛开了下文。这个选择现在看不是个太好的选择，原因很简单，它没有把单词的下文融合进来，这限制了其在更多应用场景的效果，比如阅读理解这种任务，在做任务的时候是可以允许同时看到上文和下文一起做决策的。如果预训练时候不把单词的下文嵌入到 Word Embedding 中，是很吃亏的，白白丢掉了很多信息。</p>
<h3 id="2-5-BERT"><a href="#2-5-BERT" class="headerlink" title="2.5 BERT"></a>2.5 BERT</h3><p>Bert 采用和 GPT 完全相同的两阶段模型，首先是语言模型预训练；其次是使用 Fine-Tuning 模式解决下游任务。和 GPT 的最主要不同在于在预训练阶段采用了类似 ELMO 的双向语言模型，即双向的 Transformer，当然另外一点是语言模型的数据规模要比 GPT 大。所以这里 Bert 的预训练过程不必多讲了。模型结构如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d7829030c16952?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>对比 OpenAI GPT(Generative pre-trained transformer)，BERT 是双向的 Transformer block 连接；就像单向 rnn 和双向 rnn 的区别，直觉上来讲效果会好一些。</p>
<p>对比 ELMo，虽然都是 “双向”，但目标函数其实是不同的。ELMo 是分别以</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d78290273ccc41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>和</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d782903b4227c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>作为目标函数，独立训练处两个 representation 然后拼接，而 BERT 则是以</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d782903ebac987?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>作为目标函数训练 LM。</p>
<p>BERT 预训练模型分为以下三个步骤：<strong>Embedding、Masked LM、Next Sentence Prediction</strong></p>
<h4 id="2-5-1-Embedding"><a href="#2-5-1-Embedding" class="headerlink" title="2.5.1 Embedding"></a>2.5.1 Embedding</h4><p>这里的 Embedding 由三种 Embedding 求和而成：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/28/16d78290485bc245?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<ul>
<li>Token Embeddings 是词向量，第一个单词是 CLS 标志，可以用于之后的分类任务</li>
<li>Segment Embeddings 用来区别两种句子，因为预训练不光做 LM 还要做以两个句子为输入的分类任务</li>
<li>Position Embeddings 和之前文章中的 Transformer 不一样，不是三角函数而是学习出来的</li>
</ul>
<h4 id="2-5-2-Masked-LM"><a href="#2-5-2-Masked-LM" class="headerlink" title="2.5.2 Masked LM"></a>2.5.2 Masked LM</h4><p>MLM 可以理解为完形填空，作者会随机 mask 每一个句子中 15% 的词，用其上下文来做预测，例如：my dog is hairy → my dog is [MASK]</p>
<p>此处将 hairy 进行了 mask 处理，然后采用非监督学习的方法预测 mask 位置的词是什么，但是该方法有一个问题，因为是 mask15% 的词，其数量已经很高了，这样就会导致某些词在 fine-tuning 阶段从未见过，为了解决这个问题，作者做了如下的处理：</p>
<p>80% 是采用 [mask]，my dog is hairy → my dog is [MASK]</p>
<p>10% 是随机取一个词来代替 mask 的词，my dog is hairy -&gt; my dog is apple</p>
<p>10% 保持不变，my dog is hairy -&gt; my dog is hairy</p>
<p><strong>注意：这里的 10% 是 15% 需要 mask 中的 10%</strong></p>
<p>那么为啥要以一定的概率使用随机词呢？这是因为 transformer 要保持对每个输入 token 分布式的表征，否则 Transformer 很可能会记住这个 [MASK] 就是 “hairy”。至于使用随机词带来的负面影响，文章中解释说, 所有其他的 token(即非 “hairy” 的 token)共享 15%*10% = 1.5% 的概率，其影响是可以忽略不计的。Transformer 全局的可视，又增加了信息的获取，但是不让模型获取全量信息。</p>
<h4 id="2-5-3-Next-Sentence-Prediction"><a href="#2-5-3-Next-Sentence-Prediction" class="headerlink" title="2.5.3 Next Sentence Prediction"></a>2.5.3 Next Sentence Prediction</h4><p>选择一些句子对 A 与 B，其中 50% 的数据 B 是 A 的下一条句子，剩余 50% 的数据 B 是语料库中随机选择的，学习其中的相关性，添加这样的预训练的目的是目前很多 NLP 的任务比如 QA 和 NLI 都需要理解两个句子之间的关系，从而能让预训练的模型更好的适应这样的任务。 个人理解：</p>
<ul>
<li>Bert 先是用 Mask 来提高视野范围的信息获取量，增加 duplicate 再随机 Mask，这样跟 RNN 类方法依次训练预测没什么区别了除了 mask 不同位置外；</li>
<li>全局视野极大地降低了学习的难度，然后再用 A+B/C 来作为样本，这样每条样本都有 50% 的概率看到一半左右的噪声；</li>
<li>但直接学习 Mask A+B/C 是没法学习的，因为不知道哪些是噪声，所以又加上 next_sentence 预测任务，与 MLM 同时进行训练，这样用 next 来辅助模型对噪声 / 非噪声的辨识，用 MLM 来完成语义的大部分的学习。</li>
</ul>
<ol>
<li>BERT 的评价</li>
</ol>
<hr>
<p>总结下 BERT 的主要贡献：</p>
<ul>
<li>引入了 Masked LM，使用双向 LM 做模型预训练。</li>
<li>为预训练引入了新目标 NSP，它可以学习句子与句子间的关系。</li>
<li>进一步验证了更大的模型效果更好： 12 —&gt; 24 层。</li>
<li>为下游任务引入了很通用的求解框架，不再为任务做模型定制。</li>
<li>刷新了多项 NLP 任务的记录，引爆了 NLP 无监督预训练技术。</li>
</ul>
<p><strong>BERT 优点</strong></p>
<ul>
<li>Transformer Encoder 因为有 Self-attention 机制，因此 BERT 自带双向功能。</li>
<li>因为双向功能以及多层 Self-attention 机制的影响，使得 BERT 必须使用 Cloze 版的语言模型 Masked-LM 来完成 token 级别的预训练。</li>
<li>为了获取比词更高级别的句子级别的语义表征，BERT 加入了 Next Sentence Prediction 来和 Masked-LM 一起做联合训练。</li>
<li>为了适配多任务下的迁移学习，BERT 设计了更通用的输入层和输出层。</li>
<li>微调成本小。</li>
</ul>
<p><strong>BERT 缺点</strong></p>
<ul>
<li>task1 的随机遮挡策略略显粗犷，推荐阅读《Data Nosing As Smoothing In Neural Network Language Models》。</li>
<li>[MASK]标记在实际预测中不会出现，训练时用过多 [MASK] 影响模型表现。每个 batch 只有 15% 的 token 被预测，所以 BERT 收敛得比 left-to-right 模型要慢（它们会预测每个 token）。</li>
<li>BERT 对硬件资源的消耗巨大（大模型需要 16 个 tpu，历时四天；更大的模型需要 64 个 tpu，历时四天。</li>
</ul>
<p><strong>评价</strong></p>
<p>Bert 是 NLP 里里程碑式的工作，对于后面 NLP 的研究和工业应用会产生长久的影响，这点毫无疑问。但是从上文介绍也可以看出，从模型或者方法角度看，Bert 借鉴了 ELMO，GPT 及 CBOW，主要提出了 Masked 语言模型及 Next Sentence Prediction，但是这里 Next Sentence Prediction 基本不影响大局，而 Masked LM 明显借鉴了 CBOW 的思想。所以说 Bert 的模型没什么大的创新，更像最近几年 NLP 重要进展的集大成者，这点如果你看懂了上文估计也没有太大异议，如果你有大的异议，杠精这个大帽子我随时准备戴给你。如果归纳一下这些进展就是：</p>
<ul>
<li>首先是两阶段模型，第一阶段双向语言模型预训练，这里注意要用双向而不是单向，第二阶段采用具体任务 Fine-tuning 或者做特征集成；</li>
<li>第二是特征抽取要用 Transformer 作为特征提取器而不是 RNN 或者 CNN；</li>
<li>第三，双向语言模型可以采取 CBOW 的方法去做（当然我觉得这个是个细节问题，不算太关键，前两个因素比较关键）。</li>
</ul>
<p>Bert 最大的亮点在于效果好及普适性强，几乎所有 NLP 任务都可以套用 Bert 这种两阶段解决思路，而且效果应该会有明显提升。可以预见的是，未来一段时间在 NLP 应用领域，Transformer 将占据主导地位，而且这种两阶段预训练方法也会主导各种应用。</p>
<ol>
<li>代码实现</li>
</ol>
<hr>
<p><a href="https://github.com/NLP-LOVE/ML-NLP/blob/master/NLP/16.8%20BERT/bert-Chinese-classification-task.md" target="_blank" rel="noopener">bert 中文分类实践</a></p>
<p>【<a href="https://github.com/NLP-LOVE/ML-NLP" target="_blank" rel="noopener">机器学习通俗易懂系列文章</a>】</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/26/16d6c63d2c5134b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<ol>
<li>参考文献</li>
</ol>
<hr>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/46652512" target="_blank" rel="noopener">【NLP】Google BERT 详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/49271699" target="_blank" rel="noopener">从 Word Embedding 到 Bert 模型—自然语言处理中的预训练技术发展史</a></li>
<li><a href="https://blog.csdn.net/jiaowoshouzi/article/details/89073944" target="_blank" rel="noopener">一文读懂 BERT(原理篇)</a></li>
</ul>
<blockquote>
<p>作者:<a href="https://github.com/NLP-LOVE/ML-NLP" target="_blank" rel="noopener">@mantchs</a></p>
<p>GitHub:<a href="https://github.com/NLP-LOVE/ML-NLP" target="_blank" rel="noopener">github.com/NLP-LOVE/ML…</a></p>
<p>欢迎大家加入讨论！共同完善此项目！群号:【541954936】<a href="//shang.qq.com/wpa/qunwpa?idkey=863f915b9178560bd32ca07cd090a7d9e6f5f90fcff5667489697b1621cecdb3"><img src="https://user-gold-cdn.xitu.io/2019/9/24/16d621b9608e9250?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></a></p>
</blockquote>

    </div>

    
    
    
        
      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>AILab-aida</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ailab-aida.github.io/2019/11/08/BERT 预训练模型的演进过程！(附代码)/" title="BERT 预训练模型的演进过程！(附代码)">https://ailab-aida.github.io/2019/11/08/BERT 预训练模型的演进过程！(附代码)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/算法/" rel="tag"># 算法</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/11/08/Transformer 各层网络结构详解！面试必备！(附代码实现)/" rel="next" title="Transformer 各层网络结构详解！面试必备！(附代码实现)">
                  <i class="fa fa-chevron-left"></i> Transformer 各层网络结构详解！面试必备！(附代码实现)
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/11/08/XLNet 预训练模型，看这篇就够了！(代码实现)/" rel="prev" title="XLNet 预训练模型，看这篇就够了！(代码实现)">
                  XLNet 预训练模型，看这篇就够了！(代码实现) <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-图像的预训练"><span class="nav-number">1.</span> <span class="nav-text">2.1 图像的预训练</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Word-Embedding"><span class="nav-number">2.</span> <span class="nav-text">2.2 Word Embedding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-ELMO"><span class="nav-number">3.</span> <span class="nav-text">2.3 ELMO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-GPT"><span class="nav-number">4.</span> <span class="nav-text">2.4 GPT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-BERT"><span class="nav-number">5.</span> <span class="nav-text">2.5 BERT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-Embedding"><span class="nav-number">5.1.</span> <span class="nav-text">2.5.1 Embedding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-Masked-LM"><span class="nav-number">5.2.</span> <span class="nav-text">2.5.2 Masked LM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-Next-Sentence-Prediction"><span class="nav-number">5.3.</span> <span class="nav-text">2.5.3 Next Sentence Prediction</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="AILab-aida">
  <p class="site-author-name" itemprop="name">AILab-aida</p>
  <div class="site-description" itemprop="description">涉猎的主要编程语言为 深度学习、机器学习、大数据、服务端、移动端、前端、爬虫(go、scala、Java、flutter、Python、react、Vue)等。</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/qq1074123922" title="GitHub &rarr; https://github.com/qq1074123922" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="/1074123922@qq.com" title="E-Mail &rarr; 1074123922@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AILab-aida</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script src="/lib/pjax/pjax.min.js?v=0.2.8"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  








  <script src="/js/local-search.js?v=7.4.0"></script>













    <div id="pjax">

  

  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a6d340a24e0f5044ffc3',
      clientSecret: 'edff6432acd3e21caff2696cc123e15b3ca3461c',
      repo: 'ailab-aida.github.io',
      owner: 'AILab-aida',
      admin: ['ailab'],
      id: '831c94423050d7144ad05d4319a27dd5',
        language: 'zh-CN',
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

    </div>
</body>
</html>
